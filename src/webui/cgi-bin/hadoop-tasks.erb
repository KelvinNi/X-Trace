<%
script_start_time = Time.new
log = Logger.new(STDERR)
log.datetime_format = "%Y-%m-%d %H:%M:%S"
jobid = cgi['jobid']
jobid = "" unless jobid =~ /[a-z0-9_]*/ # Don't allow weird characters
if jobid != ""
  title = "Utilization for #{jobid}"
else
  title = "Please select a job"
end
%>

<html>
<head>
  <title><%=title%></title>
  <link rel="stylesheet" href="hadoop-analysis.css" />
</head>
<body>

<h1><%=title%></h1>

<%
if jobid != ""
  io = open(PROGRESS_LOG_DIR + "/" + jobid)
  reportTexts = io.read.split(/\n\n/)
  io.close
  if reportTexts.empty?
    %>No progress reports have yet been written.<%
  else
    json_report = JSON.parse(reportTexts[-2]) # Look only at the 2nd to last report
    report = HadoopReport.new(json_report)
    log.info "loaded a new HadoopReport with #{report.length} tasks"
    log.info report.to_s
    log.info report.tasks.select{|x| x.is_success}.length.to_s + " successful tasks"
   
    %><table><%
    %><tr><td>Duration:</td><td><%=report.duration.round%>s</td></tr><%
    %><tr><td>Hosts:</td><td><%=report.tasks.map{|x| x.tracker}.uniq.length%></td></tr><%
    %></table><br/>
    
    <%=
    #output a pretty table of stats
    headers = %w{Tasks Count Mean(s) Med(s) Dev(s) Min(s) Max(s) 95%(s) Sum(s) Useful(s) Useless(s)}
    values = []
    rows = []
    rows << ["All Tasks:",report.tasks, report.task_stats]
    rows << ["Maps:",report.maps,report.map_stats]
    rows << ["Reduces:",report.reduces, report.reduce_stats]
    #TODO(andyk): add rows for each of the spec_types of tasks
    #rows << ["Good Tasks:",report.tasks.filter, report.reduce_stats]
    rows.each do |t|
      row = []
      row << t[0]
      row << t[1].length
      if t[2].values.length > 0 
        [lambda{|x|x.mean},lambda{|x|x.med},lambda{|x|x.std},lambda{|x|x.min},
        lambda{|x|x.max},lambda{|x|x.percentile(95)}].each do |y|
          row << y.call(t[2]).round
        end

        row << t[2].sum.round.to_s + " (#{percentify(t[2].sum/report.task_stats.sum)})"
        useful = t[1].select{|x|x.spec_state == :good or 
                             x.spec_state == :suspect_good or 
                             x.spec_state == :spec_good
                         }.map{
                           |x|x.duration
                         }.inject(0) {
                           |sum,x| sum + x
                         }.round
        row << useful.to_s + " (#{percentify(useful/t[2].sum)})"

        useless = t[1].select{|x|x.spec_state == :suspect_killed or 
                                 x.spec_state == :spec_killed
                             }.map{
                               |x|x.duration
                             }.inject(0) {|sum,x| sum + x}.round
        row << useless.to_s + " (#{percentify(useless/t[2].sum)})"
      else
        (headers.length-2).times{row << "N/A"}
      end
      values << row
      row = nil
    end
    html_table headers, values
    %>
    <%
    ################################################################
    #first draw graphs for map tasks, then the same graphs for reduce tasks
    plots = []
    [0,1].each do |task_type|
      all_tasks = task_type == 0 ? report.maps : report.reduces
      type_name = task_type == 0 ? "map" : "reduce"
      
      file_suffixes = ["good", "suspect-finished", "suspect-killed",
                       "speculative-finished", "speculative-killed"]
      file_suffixes.map!{|x| x + "-" + type_name} 
      
      plots <<  get_plot_2(jobid, type_name + "_distr") do |graph_file|
        data_files = file_suffixes.map{|x| graph_file + "." + x + ".txt"}
        data_ios = data_files.map{|f_name| File.new(f_name, "w")}
      
        all_tasks.sort{|a,b| b.duration<=>a.duration}.each_with_index do |x,i|
          data_line = "#{i+1}\t#{x.duration}\n"
          zero_data_line = "#{i+1}\t0\n"
          
          if x.spec_state == :good then
            data_ios[0] << data_line; 
            #log.info x.to_s
          else data_ios[0] << zero_data_line
          end
          
          if x.spec_state == :suspect_good then data_ios[1] << data_line
          else data_ios[1] << zero_data_line
          end
          
          if x.spec_state == :suspect_killed then data_ios[2] << data_line
          else data_ios[2] << zero_data_line
          end
          
          if x.spec_state == :spec_good then data_ios[3] << data_line
          else data_ios[3] << zero_data_line
          end
          
          if x.spec_state == :spec_killed then data_ios[4] << data_line
          else data_ios[4] << zero_data_line
          end
        end
        data_ios.each{|x| x.close}
        # Return GNUPlot commands
        "set title '#{type_name.capitalize} Durations'
         set xlabel 'Task number'
         set ylabel 'Duration (s)'
         set yrange [0:]
         plot '#{data_files[0]}' title '#{file_suffixes[0]}' with boxes fs solid,\\
           '#{data_files[1]}' title '#{file_suffixes[1]}' with boxes fs solid,\\
           '#{data_files[2]}' title '#{file_suffixes[2]}' with boxes fs solid,\\
           '#{data_files[3]}' title '#{file_suffixes[3]}' with boxes fs solid,\\
           '#{data_files[4]}' title '#{file_suffixes[4]}' with boxes fs solid"
      end
      %><img src="<%=plots.last%>" /><p><ul>
      <% file_suffixes.each do |suf| %>
        <li><a href="<%= plots.last + "." + suf + ".txt\"/>" + suf %> Data</a></li>
      <% end %>
      </ul></p>
      <% 
      plots << get_plot_2(jobid, type_name+"_distr_grouped_by_task_type") do |graph_file|
        data_files = file_suffixes.map{|x| graph_file + "." + x + ".txt"}
        data_ios = data_files.map{|f_name| File.new(f_name, "w")}
        tasks = []
        5.times do tasks << StatCounter.new end

        all_tasks.sort{|a,b| b.duration<=>a.duration}.each_with_index do |x,i|
          
         if x.spec_state == :good then
            tasks[0] << x.duration 
          end
          
         if x.spec_state == :suspect_good then
            tasks[1] << x.duration
          end
         
         if x.spec_state == :suspect_killed then
            tasks[2] << x.duration
          end
         
         if x.spec_state == :spec_good then
            tasks[3] << x.duration
          end
          
         if x.spec_state == :spec_killed then
            tasks[4] << x.duration
          end
        end
        i = 0
        tasks.each_with_index do |sc,k|
          if sc.values.length < 1 then data_ios[k] << "0\t0\n" end
          sc.values.each do |v|
            data_ios[k] << "#{i+1}\t#{v}\n"
            i += 1
          end
        end
        data_ios.each{|x| x.close}
        # Return GNUPlot commands
        "set title '#{type_name.capitalize} Durations'
         set xlabel 'Task number'
         set ylabel 'Duration (s)'
         set yrange [0:]
         plot '#{data_files[0]}' title '#{file_suffixes[0]}' with boxes fs solid,\\
           '#{data_files[1]}' title '#{file_suffixes[1]}' with boxes fs solid,\\
           '#{data_files[2]}' title '#{file_suffixes[2]}' with boxes fs solid,\\
           '#{data_files[3]}' title '#{file_suffixes[3]}' with boxes fs solid,\\
           '#{data_files[4]}' title '#{file_suffixes[4]}' with boxes fs solid"

      end
      %><img src="<%=plots.last%>" /><p><ul>
      <% file_suffixes.each do |suf| %>
        <li><a href="<%= plots.last + "." + suf + ".txt\"/>" + suf %> data</a></li>
      <% end %>
      </ul></p>
      <% 
      plots << get_plot_2(jobid, type_name+"_distr_grouped_by_host") do |graph_file|
        data_files = (file_suffixes << "mean_task_length_per_tracker " + 
                      type_name).map{|x| graph_file + "." + x + ".txt"}
        data_ios = data_files.map{|f_name| File.new(f_name, "w")}
        task_trackers = Hash.new {|key,value| key[value] = 
            Array.new(6) {StatCounter.new}}

        all_tasks.sort{|a,b| b.duration<=>a.duration}.each_with_index do |x,i|
          if x.spec_state == :good then
            task_trackers[x.tracker][0] << x.duration
          end
          
          if x.spec_state == :suspect_good then
            task_trackers[x.tracker][1] << x.duration
          end
         
          if x.spec_state == :suspect_killed then
            task_trackers[x.tracker][2] << x.duration
          end
        
          if x.spec_state == :spec_good then 
            task_trackers[x.tracker][3] << x.duration
          end
       
          if x.spec_state == :spec_killed then 
            task_trackers[x.tracker][4] << x.duration
          end
          #also track an aggregate view of all tasks per this task tracker
          task_trackers[x.tracker][5] << x.duration

        end
        
        i = 0 
        task_trackers.sort{|a,b| b[1][5].mean <=> a[1][5].mean}.each do |tt|
          tt_name = tt[0]
          tt[1].each_with_index do |tt_task_type, k|
            if k==5 then
              data_ios[5] << "#{i+1-tt_task_type.values.length/2}\t#{tt_task_type.mean}\t#<--#{tt_name}\n"
            else
              tt_task_type.values.each do |v|
                data_ios[k] << "#{i+1}\t#{v}\t###{tt_name}\n"
                data_ios[0..4].each_with_index {|dio,ind| if ind!=k : dio << "#{i+1}\t0\t#<--zero so that the #{file_suffixes[k]} task can be drawn\n" end}
                i += 1
              end
            end
          end
          (all_tasks.length/task_trackers.length/2).times {data_ios[0..4].each {|dio| dio << "#{i+1}\t0\t#<--spacer\n"}; i+=1}
        end
        
        data_ios.each{|x| x.close}
        # Return GNUPlot commands
        "set title '#{type_name.capitalize} Durations'
         set xlabel 'Task number'
         set ylabel 'Duration (s)'
         set yrange [0:]
         plot '#{data_files[0]}' title '#{file_suffixes[0]}' with boxes fs solid,\\
           '#{data_files[1]}' title '#{file_suffixes[1]}' with boxes fs solid,\\
           '#{data_files[2]}' title '#{file_suffixes[2]}' with boxes fs solid,\\
           '#{data_files[3]}' title '#{file_suffixes[3]}' with boxes fs solid,\\
           '#{data_files[4]}' title '#{file_suffixes[4]}' with boxes fs solid,\\
           '#{data_files[5]}' title '#{file_suffixes[5]}' with lines lw 1"

      end
      %><img src="<%=plots.last%>" /><p><ul>
      <% file_suffixes.each do |suf| %>
        <li><a href="<%= plots.last + "." + suf + ".txt\"/>" + suf %> data</a></li>
      <% end %>
      </ul></p>
      <%
    end
  end
else
  %><ul><%
  files = []
  Dir.foreach(PROGRESS_LOG_DIR) {|f| files << f}
  files.sort.each do |file|
    unless file =~ /^\./ # Ignore directory entires and hidden files
    %>
    <li><a href="<%=SERVER_URL+"/hadoop-tasks.rb?jobid="+file%>"><%=file%></a></li>
    <%
    end
  end
  %></ul><%
end
%>
</body>

<hr />
<p>Page generated in <%=Time.new-script_start_time%> seconds.</p>

</html>
